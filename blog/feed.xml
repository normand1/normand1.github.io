<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/blog/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="/blog/" rel="alternate" type="text/html" /><updated>2016-11-26T12:40:50-08:00</updated><id>/blog//</id><title type="html">Dave’s Code Blog</title><subtitle>My blog for all things I'm coding. I'll post tutorials about things I'm working on and things I'm interested in. That will mostly include Swift, NodeJS, AWS and Unity VR development.
</subtitle><entry><title type="html">Automating Swift Middleware With Swagger Codegen</title><link href="/blog/swift/swagger/codegen/2016/11/25/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Automating Swift Middleware With Swagger Codegen" /><published>2016-11-25T21:43:59-08:00</published><updated>2016-11-25T21:43:59-08:00</updated><id>/blog/swift/swagger/codegen/2016/11/25/welcome-to-jekyll</id><content type="html" xml:base="/blog/swift/swagger/codegen/2016/11/25/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve ever worked on an app with it’s own backend service before then you may have used swagger’s easy to use (and generate) &lt;a href=&quot;https://github.com/swagger-api/swagger-ui&quot;&gt;Swagger UI&lt;/a&gt; documentation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/Screen Shot 2016-11-23 at 7.01.48 PM.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Swagger’s UI tool makes it easy to learn about the features of a backend service you’d like to interact with without needing to dig through interminable and abstruse documentation. Swagger’s documentation is easy to read, understand and allows you to test calls directly from your browser!&lt;/p&gt;

&lt;p&gt;One of Swagger’s lesser known features is the capability to generate server AND client code (yes even Swift!).&lt;/p&gt;

&lt;p&gt;All this is made possible with Swagger’s Open API Specification which defines a standard by which a REST API’s functionality can be defined. In other words once you create a swagger spec document (in either json or yml) that defines the expected behavior of an API you can just generate the code to interact with that endpoint because the expectations on both sides of the agreement have already been defined. You’ll see how this works in a minute when we start writing code.&lt;/p&gt;

&lt;p&gt;To demonstrate how we can quickly write both the server-side and client-side code for an app we’re going to build an app for keeping track of Dwarfs we meet while playing &lt;a href=&quot;http://www.bay12games.com/dwarves/features.html&quot;&gt;Dwarf Fortress&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First we’ll need to create a swagger specification that will define the entire backend API for our app. Our API will handle simple CRUD operations for keeping track of Dwarf migrants we meet in Dwarf Fortress.&lt;/p&gt;

&lt;p&gt;To start off, we’ll just need to create a new swagger.yml specification file. So change directory to somewhere you’d like to create a new project. Once you’ve created a new folder / directory to store your project create a swagger.yml file.
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ touch swagger.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then open that file in your favorite text editor and paste in the following code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;ss&quot;&gt;swagger: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2.0&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;info:
description: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Dwarf Tracker endpoints&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;version: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.0.1&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;title: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Dwarf Tracker Service API&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;host: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;localhost:3000&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;schemes:
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;http&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;produces:
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;application/json&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The above block of code is laying down some baseline information about our API. It’s specifying the version of the Open API specification we’re using (currently the latest 2.0) as well as some other basic information about our API like a description and title. The &lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt; is very important information here, because it specifies the hostname and port we’ll be making network requests against (we’re using localhost for this demo, I’ll cover how to set that up later).&lt;/p&gt;

&lt;p&gt;Next we’ll set up the different &lt;code class=&quot;highlighter-rouge&quot;&gt;paths&lt;/code&gt; for our API. Paste the next block of code directly beneath the previous block to continue creating our Swagger API specification.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;sr&quot;&gt;/dwarf:
post:
summary: &quot;Post a new Dwarf&quot;
description: &quot;endpoint for posting a newly created dwarf to the server&quot;
operationId: &quot;postDwarf&quot;
parameters:
- name: payload
in: body
required: true
description: A single JSON object containing the dwarf definition
schema:
$ref: '#/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;definitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Dwarf&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
responses: 
200:
description: indicates a successful update
get:
summary: &quot;All dwarves&quot;
description: &quot;Gets all dwarves&quot;
operationId: getDwarves
responses:
200:
description: &quot;An array of dwarf objects&quot;
schema:
type: array
items:
$ref: '&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#/definitions/Dwarf'&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now our API has a single route: /dwarf
When we call this endpoint we would use the url: http://localhost:3000/dwarf&lt;/p&gt;

&lt;p&gt;Next we have defined two HTTP Methods in our API for interacting with this single endpoint. If we’d like to POST a new dwarf we can see we’ve specified that a &lt;code class=&quot;highlighter-rouge&quot;&gt;payload&lt;/code&gt; will be required in the &lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt;. Additionally we’ve defined a &lt;code class=&quot;highlighter-rouge&quot;&gt;schema&lt;/code&gt; with this strange bit of syntax:
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ref: '#/definitions/Dwarf'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is a reference to a definition of an object that holds data types that can be consumed and produced by operations. These data types can be primitives, arrays or models. We can define objects that we’re going to re-use in the specification so we don’t need to type them over and over again. This will be the final part of our specification.&lt;/p&gt;

&lt;p&gt;Take the following code snippet and post it below your last in the same file to finish the swagger.yml file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;ss&quot;&gt;definitions:

&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Dwarf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;type: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;description: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sturdy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creature&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fond&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drink&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;industry!&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;properties:
name:
type: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;age: 
type: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;id:
type: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;##Prerequisites
Now that we have the swagger specification that defines our interaction between our server-side code and our client-side code we’re ready to start generating them both! But first we’ll need to download a few tools to help us out, so make sure you have these installed before you proceed any farther:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Xcode 8.*&lt;/li&gt;
  &lt;li&gt;NodeJS v 0.12.*&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next you want to install Swagger Codegen. The easiest way to install Swagger Codegen on a mac is:
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ brew install swagger-codegen&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you need further install instructions check here: https://github.com/swagger-api/swagger-codegen#prerequisites
##Client-side Code Generation
Since you may need to run the next script often (anytime the swagger spec changes) you’re going to want to put the following script in it’s own shell script file. The following command will generate your front end swift code when run, but right now we’re just going to save it for easy future execution.
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ echo &quot;swagger-codegen generate -i swagger.yml -l swift -o SwaggerClient&quot; &amp;gt; client_build.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Open the client_build.sh file in your favorite text editor and you should see this:
&lt;code class=&quot;highlighter-rouge&quot;&gt;swagger-codegen generate -i swagger.yml -l swift -o SwaggerClient&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As you can see the above command will reference the .yml API specification we build a minute ago and it will out put an SDK based on whatever language we specify with the -l parameter (in this case swift). Finally -o specifies an output directory we haven’t yet created… so create an output directory.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ mkdir SwaggerClient&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Make sure you have permission to execute the script we just created by running:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ chmod a+x client_build.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, execute the script:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./client_build.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Assuming everything worked as expected you should see a number of new files in your SwaggerClient folder.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/Screen Shot 2016-11-24 at 12.05.49 AM.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you’re SwaggerClient Folder looks like the one above you’re in good shape.&lt;/p&gt;

&lt;p&gt;##Server-side Code Generation&lt;/p&gt;

&lt;p&gt;Follow the same steps again, but for the server-side code this time. Create a new folder for the swagger server code named &lt;code class=&quot;highlighter-rouge&quot;&gt;SwaggerServer&lt;/code&gt; and replace &lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;nodejs-server&lt;/code&gt; in the build script as so.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ echo &quot;swagger-codegen generate -i swagger.yml -l nodejs-server -o SwaggerServer&quot; &amp;gt; server_build.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Make sure the script has the executable permission, and run the script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/Screen Shot 2016-11-24 at 12.34.46 AM.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You should now have files in your SwaggerServer folder that resemble the files above.
##Starting and Running the Server&lt;/p&gt;

&lt;p&gt;First we need to install the any packages our Swagger Server needs to run.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ npm install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now we can start the server.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ npm run start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If everything worked you should see the following message:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Your server is listening on port 3000 (http://localhost:3000)
Swagger-ui is available on http://localhost:3000/docs&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:3000/docs&lt;/code&gt; in your browser do view the documentation for our API.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/Screen Shot 2016-11-24 at 12.45.40 AM.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this you can send POST and GET requests to the API. You will get hardcoded responses, but that’s good enough for now!&lt;/p&gt;

&lt;p&gt;Sending a GET request to http://localhost:3000/dwarf via SwaggerUI will result in this response:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/Screen Shot 2016-11-24 at 12.53.06 AM.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We are receiving a response with an array of Dwarf objects, just as we’d defined earlier in our swagger.yml file.&lt;/p&gt;

&lt;p&gt;##Running the iOS App&lt;/p&gt;

&lt;p&gt;Now that the server is running and accepting requests, we’re ready to start building the rest of the iOS app. So far we’ve auto-generated the middleware and networking code that we’ll be using to communicate with the our backend service, but we still need to create a new Xcode project and pull the networking code we generated earlier into the final app.&lt;/p&gt;

&lt;p&gt;Open Xcode and create a new Xcode project. Create a “Single View Application” and make sure you save the project inside the same folder you’ve saved your SwaggerClient folder in. My folder structure looks like this after inserting my Xcode Project files.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/Screen Shot 2016-11-24 at 9.37.32 PM.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once you’ve created the Xcode project it’s time to drag the Swagger Client code into the project and make sure you de-select “copy items if needed”so we don’t create a second copy of the directory.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/Screen Shot 2016-11-24 at 9.26.56 PM.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code we generated from Swagger uses the AlamoFire library to make the network requests we’ll need to communicate with the server, so we’ll need to install that next. For further installation instructions follow the examples on the &lt;a href=&quot;https://github.com/Alamofire/Alamofire#installation&quot;&gt;AlamoFire Github page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/image1.png&quot; alt=&quot;My helpful screenshot&quot; /&gt;&lt;/p&gt;</content><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>
